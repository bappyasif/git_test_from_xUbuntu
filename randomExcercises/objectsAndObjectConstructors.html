<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object and Object Constructors</title>
</head>

<body>
    <script>
        // objects as a design pattern
        // consider these two models:
        // model 01:
        let p1Name = "tim";
        let p2Name = "jenn";
        let p1Marker = "X";
        let p2Marker = "O";
        // model 02:
        let playerOne = {
            name: "tim",
            marker: "X"
        };
        let playerTwo = {
            name: "jenn",
            marker: "O"
        };
        // consider an ecommerce site product where keeping track of all these related information regarding any product so vital that individual naming like first model is unfeasible
        // and that brings us to Object Constructors: when you have a specefic Object type and need to duplicate it often times then Constructor functions are way to go:
        function Player(name, marker) {
            this.name = name;
            this.marker = marker
        }
        let player01 = new Player("rene", "X"); // calling function with new will create an instance of that Function
        console.log(player01.name, player01.marker);
        // just like object literal, it's possible to have object methods in it:
        function Player(name, marker) {
            this.name = name;
            this.marker = marker;
            this.sayName = function () {
                console.log(name);
            }
        }
        let player02 = new Player("hana", "O");
        player01.sayName();
        player02.sayName();

        // Excercises:
        // write a constructor for making Book objects with title, author, numOfPages and whether you have read that book or not
        function Book(title, author, pages, read) {
            this.title = title;
            this.author = author;
            this.pages = pages;
            this.read = read;
            this.info = function () {
                return `${this.title} by ${this.author}, ${this.pages} pages, ${this.read}`;
            }
        }
        let theHobbit = new Book("The Hobbit", "J.R.R. Tolkien", 295, "have not read yet");
        console.log(theHobbit.info());

        // Object Prototype
        // All objects in JS have a "prototype", to simply put it "prototype" is an another Object that original object inherits from, that is to say original object has access to ll of it's "prototype"'s object methods and properties
        // - JS function/Object has "prototype" property initially empty but when new methods are addedto it, instance objects from  that function/Object will also have acces to those added methods as well, it's mainly for inheritance(designed) capability
        // - "prototype" in JS is "prototype attribute" which means every Object inherits properties from some other Object and it is this other Object that's Object's "prototype" attribute or parent, and it works like a lineage, when not found in immediate/original object than it looks up into "prototype" chain untill it finds any or undefined
        // Constructor, is a function and used for initialization of new Objects, and also inherits a property called constructor, which holds which constructor of an Object
        console.log(theHobbit.constructor, theHobbit.constructor.name);
        // - all objects areacted with object literals ( Object{} or Object.prototype) and constructors(new () or Object.prototype) inherits from Object.prototype
        let uAcc = new Object(); // constructors
        uAcc = { name: "mike" }; // lieterals
        // prototype attribute of Objects created with a constructor function inherits from Object.prototype
        // Prototype Usage:
        // - Prototype Property, for prototype-based inheritance, all inheritance in JS made possible through "prototype" property
        function Plant() {
            this.country = "world";
            this.isOrganic = true;
        }
        // adding more properties to Plant prototype property
        Plant.prototype.showNameAndColor = function () {
            console.log("this is a " + this.name + " and color is " + this.color);
        }
        // adding more methods to Plant prototype property
        Plant.prototype.checkOrganic = function () {
            if (this.isOrganic) {
                console.log("Organic, yeah");
            }
        }
        // Another constructor
        function Fruit(name, color) {
            this.name = name;
            this.color = color;
        }
        // setting Fruit's prototype to Plant's prototype thus inheriting all of Plant's methods and propertis
        // Fruit.prototype = Plant.prototype
        // Fruit.prototype = Object.create(Plant);
        Fruit.prototype = new Plant();
        // creating a new Object
        let aBanana = new Fruit("Banana", "Yellow");
        console.log(aBanana.name, aBanana.color);
        // lets access methods from Plant constructor function as they both share same prototype object
        // console.log(aBanana.showNameAndColor());
        // console.log(aBanana.isOrganic)
        aBanana.showNameAndColor();
        aBanana.checkOrganic();
        // - Prototype attribute, accessing propertiees on objects through inheritence and move up "prototype" chain throughout lineage if not found returns undefined
        // it's same concept as prototypeinheritance except we are now focusing specifically on how JS objects acccess properties and methods via prototype
        let smFrnds = { name: "Bill" };
        console.log(smFrnds.name); // first loks into original object than if not found would have moved up chain untill found or undefined
        smFrnds.toString(); // as in original object there was no toString() method it moves up Object.prototype and looks for a method name toString which it finds and inherited from to be used in original object
        // console.log(smFrnds.toString());
        // - Object.prototype properties are inherited by all Objects:
        function People() {
            this.superstar = "Michael Jackson";
        }
        People.prototype.athlete = "Tiger Woods"; // creating another property "athlete"
        let famousPerson = new People();
        console.log(famousPerson.superstar);
        famousPerson.superstar = "Steve Jobs"; // overriding previous superstar value, as it's not available in famousPerson object directly it looks up in chain and finds it and does moderation to that,once found search is done through chain
        console.log(famousPerson.superstar);
        console.log(famousPerson.athlete); // with same concepts it gets value of "athlete" from up in prototype chain and prints it

        // More On Prototypal Inheritance
        // "prototype" is either null or referenced to another object and thus implementing inheritance without copying or recreating same properties and methods in it, also can be accessed via "__proto__"
        let animal = {
            eats: true
        };
        let rabbit = {
            jumps: true
        };
        rabbit.__proto__ = animal // which is equivalent to rabit.prototype = animal
        console.log(Object.getPrototypeOf(rabbit));
        // now if we read a property from "rabbit" and it's missing it'll automatically look into and find it from animal
        console.log(rabbit.eats, rabbit.jumps);
        console.log(animal.eats, animal.jumps); // "rabbit" prototypically inherited from "animal" not other way round
        // so, when animal has some useful utitlity finctions in it, rabbit gets access to those as well with out redefinfing them for themselves
        animal.walk = function () {
            console.log("Animal Walk");
        }
        console.log(animal);
        rabbit.walk(); // walk() is taken from animal through prototype inheritance
        // prototype can or usually be longer:
        let longEar = {
            earLength: 11,
            __proto__: rabbit
        }
        longEar.walk(); // inheriting from animal object
        console.log(longEar.jumps); // inheriting from rabbit object
        // when something you're looking for not available in object in question it move  up "prototype" chain until it finds it or else returned undefined
        // - referneces can't go in cirlce, if we try to assign __proto__ in a circle JS will throw an error (e.g. animal.__proto__ = rabbit)
        // - value of __proto__ can be either an object or null, other types are ignored, also an object can not be inherited from two others, meaning it can only have one "prototype" reference from it to "prototype" chain not multiple one's
        // - __proto__ is not same as internal "prototype" property, __proto__ is a gettr/setter for "prototype"
        // - __proto__ is bit outdated and modern JS suggests to use Object.getPrototypeOf/Object.setPrototypeOf functions instead for "prototype" getter/setter capabilities
        // "prototype" is only for used for reading properties, write/delete operations work with object directly
        rabbit.walk = function () {
            console.log("Rabbit, Bounce-Boounce!!");
        }
        rabbit.walk(); // call immediately finds walk() in object and exceutes it without using "prototype" chain
        // accessor properties are an exception as assignmentis handled by a setter function, when writing such a property is actually same as calling a function
        let user = {
            name: "Cecilia",
            surname: "Prolly",
            set fullName(value) {
                [this.name, this.surname] = value.split(" ");
            },
            get fullName() {
                return `${this.name} ${this.surname}`;
            }
        };
        let admin = {
            __proto__: user,
            isAdmin: true
        };
        console.log(admin.fullName);
        admin.fullName = "Alice Propper"; // admin state is modified
        console.log(admin.fullName, user.fullName); // user state is protected
        // admin.fullName property has a getter in user "prototype" so it's get called,  and for admin.fullName = "" calls on setter function from user "prototype"

        // Value of "this", "this" is not affected by "prototype" at all rather it matters from call stack, as in where method is being called on, it's object before dot is value of "this"
        // when inheriting objects runs inherited methods they will modify teir own state not in state of object it is inheriting from
        animal.sleep = function () {
            this.isSleeping = true;
        };
        rabbit.name = "White Rabbit";
        console.log(rabbit.isSleeping);
        rabbit.sleep(); /// modifies rabbit.isSleeping
        console.log(rabbit.isSleeping);
        console.log(animal.isSleeping); // undefined, animal didn't invoked sleep or defined isSleeping property for itself in "prototype", thus methods are shared but object state is not

        // for..in loop, iterates over inherited properties too
        console.log(Object.keys(rabbit)); // Object.keys(..) Object.values(..) operate on object itself, properties from "prototype" are not taken into account
        // for(let key in rabbit) typeof(rabbit[key]) !== "object" ? console.log(key, rabbit[key]) : console.log(key, rabbit[key]())
        for (let key in rabbit) console.log(key, rabbit[key]);
        // we can use .hasOwnProperty(key) to be assured of if it has its own property named "key"
        for (let key in rabbit) {
            let isOwn = rabbit.hasOwnProperty(key); // hasOwnProperty(..) is inherited from Object.prototype, which is enumerable
            if (isOwn) console.log(`our ${key}`);
            else console.log(`inherited ${key}`);
        }

        // Excercises:
        // task#01: working with prototype:
        animal = {
            jumps: null
        };
        rabbit = {
            __proto__: animal,
            jumps: true
        };
        console.log(rabbit.jumps); // true
        delete rabbit.jumps;
        console.log(rabbit.jumps); // null
        delete animal.jumps;
        console.log(rabbit.jumps); // undefined

        // task02: searching algorithm:
        let head = {
            glasses: 1
        };
        let table = {
            pen: 3,
            __proto__: head
        };
        let bed = {
            sheet: 1,
            pillow: 2,
            __proto__: table
        };
        let pockets = {
            money: 2000,
            __proto__: bed
        };
        console.log(pockets.pen, bed.glasses);
        console.log(head.glasses, bed.glasses); // performance wise it amkes no difference whether we take a property from object or prototype, they remember where property was found and use it for next request, so optimization is safe

        // task#03: where does it write:
        animal = {
            eat() {
                this.full = true;
            }
        };
        rabbit = {
            __proto__: animal
        };
        rabbit.eat(); // eat() gets called from rabbit object and thus value of "this" will be object before dot meaning "rabbit"
        console.log(rabbit.full, animal.full);

        // task#04: why are both hamsters full:
        let hamster = {
            stomach: [],
            eat(food) {
                // this.stomach.push(food);
                this.stomach = [food]; // this.stomach= does not look up a stomach, and value is directly written into object of calling "this"
            }
        };
        let speedy = {
            // stomach: [],
            __proto__: hamster
        };
        let lazy = {
            // stomach: [],
            __proto__: hamster
            // __proto__: speedy
        }
        // this one found food
        speedy.eat("apple");
        console.log(speedy.stomach); // apple
        // so is this one, why? fix pleaase and fixed using this.stomach= or using individual stomach for each object
        console.log(lazy.stomach);

        // F.prototype, new objects can be created with a constructor function like new F(), F.prototype === new F()
        animal = {
            eats: true
        };
        function Rabbit(name) {
            this.name = name;
        }
        Rabbit.prototype = animal;
        rabbit = new Rabbit("white Rabbit"); // rabbit.__proto__ =  animal
        console.log(rabbit.eats); // true, through prototype property or chain
        // F.prototype only used when new F() is called and assigns "prototype" of this new object
        // Default F.prototype, constructor property, every function has "prototype" even if we don't supply it
        // Default "prototype" object has only "constructor" property in it, that points back to constructor function itself
        function Rabbit() {} // default prototype, Rabbit.prototype = {constructor: Rabbit};
        // console.log(Rabbit.prototype.constructor === Rabbit, Rabbit.constructor === Rabbit);
        // console.log(Rabbit.prototype.constructor);
        rabbit = new Rabbit(); // inherits from {constructor: Rabbit}
        // console.log(rabbit.constructor === Rabbit, rabbit.prototype.constructor === Rabbit);
        // Rabbit.prototype.constructor = Rabbit
        console.log(rabbit.constructor === Rabbit);
        function Rabbit(name) {
            this.name = name;
            console.log(name, this.name);
        }
        rabbit =  new Rabbit("White Rabbit");
        // let rabbit02 = new rabbit.constructor("Black Rabbit");
        let rabbit02 = new rabbit.constructor("Black Rabbit");
        console.log(rabbit, rabbit02, rabbit.name, rabbit02.name);
        // JS doesn't ensure right "constructor" value, it depends on us, if we replace defaultt "prototype" there'll be no "constructor" in it:
        function Rabbit1() {}
        Rabbit1.prototype = {
            jumps: true
        };
        rabbit = new Rabbit1();
        console.log(rabbit.constructor === Rabbit1, Rabbit1.prototype.jumps === true);
        Rabbit1.prototype = {
            jumps: true,
            constructor: Rabbit1 // manually adding constructor property
        };
        rabbit = new Rabbit1();
        console.log(rabbit.constructor === Rabbit1);
        // Excercises:
        // Task#01.01: Changing "prototype":
        function Rabbit2() {}
        Rabbit2.prototype = {
            eats: true
        };
        rabbit = new Rabbit2();
        Rabbit2.prototype = {}; // Rabbit2.prototype setsup "prototype" for new objects but not fr already existing ones
        console.log(rabbit.eats); // !undefined but true!!
        // Task#01.02:
        function Rabbit2() {}
        Rabbit2.prototype = {
            eats: true
        };
        rabbit = new Rabbit2();
        Rabbit2.prototype.eats =  false
        // console.log(Rabbit2.prototype.eats); // undefined
        console.log(rabbit.eats); // false
        // Task#01.03:
        function Rabbit2() {}
        Rabbit2.prototype = {
            eats: true
        };
        rabbit = new Rabbit2();
        delete rabbit.eats; // eats in Rabbit2.prototype not in rabbit
        console.log(rabbit.eats); // !undefined but true!!
        // Task#01.04:
        function Rabbit2() {}
        Rabbit2.prototype = {
            eats: true
        };
        rabbit = new Rabbit2();
        delete Rabbit2.prototype.eats;
        console.log(rabbit.eats); // undefined
        // Task#02:01:Create an object with same constructor: create another with "obj" unknown constructor: where such code works:
        function Obj() {
            this.name = "Baeeebeee";
        }
        let obj = new Obj();
        let obj2 = new obj.constructor();
        // let obj2 = new Obj();
        // console.log(Object.getPrototypeOf(obj2).name);
        console.log(obj2.name, Obj.prototype.constructor === Obj);
        // Task#02:01:where such code does not work: when Obj.prototype gets overwritten and forget to recreate "constructor" to reference Obj then it'd fail:
        function Obj2(name) {
            this.name = name;
        }
        Obj2.prototype = {}
        obj = new Obj2("Baeeeebeee");
        obj2 = new obj.constructor("sayWho");
        console.log(obj2.name); // undefined, asd "constructor" is not referenced to Obj2 after overwritting Obj2.prototype default object without recreating "constructor" in it



        /**
        // Object References and copying: from JavaScript.info
        // fundamental difference between objects vs primitives is objects are stored and copied by "refernce" where as primitives are always copied as a whole "value"
        let message = "Hello";
        let phrase = message; // two distinc variables with value "Hello"
        // unlike objects, stores not object directly rather memory address of it or reference to it
        user = {
            name: "someBody" // object stored somewhere in memory and user object has a reference to it
        };
        // when object variable is copied, only reference of it gets copid not object itself
        admin = user; // reference copied, now both admin and user variables has reference to it or Object
        admin.name = "another";
        console.log(admin.name, user.name); // changes made from one variable will be passed on to other variables that share same reference to that object
        // comparison by reference, two objects are only equal if they are same object
        let a = {};
        let b = a;
        console.log(a == b, a === b); // both sharing same reference
        a = {};
        b = {};
        console.log(a == b, a === b); // comparing two independent object
        // cloning and merging, Object.assign, copying an object variable creates one or more reference to same object
        // cloning is rarely used in JS, most times copying by reference is used instead and stand good for it
        // but when needed to be duplicated and copying them on primitive value level, then we employ solution like this:
        user = {
            name: "Doe",
            age: 29
        };
        let clone = {} // empty object
        // lets clone all user properties into clone object
        for (let key in user) clone[key] = user[key];
        // now clone object also has same contents as user object andd they are independent of each other
        console.log(clone.name);
        clone.name = "Jane";
        console.log(clone.name, user.name); // original object stays protected
        // we can also use Object.assign for cloning as well, syntax Object.assign(dest, [src1,src2..])
        // - first argument is destination object
        // - firther arguments are source objects
        // it copies properties from source object to destination object, and call returns destination object from argument list
        let permission01 = { canView: true };
        let permission02 = { canView: true };
        // copies alll properties from permission01 and 02 into user object
        Object.assign(user, [permission01, permission02]);
        console.log(user);
        // if copied name already exist then value gets overwritten
        user = { name: "Doe" };
        Object.assign(user, { name: "Jane" });
        console.log(user.name);
        // it can also be used as an replacement fo for..in loop use case
        user = {
            name: "Doe",
            age: 29
        };
        // clone = Object.assign(clone, user);
        clone = Object.assign({}, user);
        console.log(clone.name);
        // Nested Cloning, properties can also be referenced to other objects
        // consider this:
        user = {
            name: "Jane",
            sizes: {
                height: 182,
                width: 35
            }
        };
        clone = Object.assign({}, user);
        console.log(user.sizes === clone.sizes); // share same object rather needs to be independent
        // to fix this we should use a cloning loop that examines if it;'s an object then replicate it's structure as it is known as "deep cloning"
        // we'll have to use recursion or use library utility function _.cloneDeep(obj)
        // recursion#01:
        function deepCloning(obj) {
            let cloned = {};
            for (let key in obj) {
                if (typeof obj[key] === "object" && obj[key] !== null) {
                    cloned[key] = deepCloning(obj[key]);
                } else {
                    cloned[key] = obj[key];
                    // Object.assign(clone, user);
                }
            }
            return cloned;
        }
        // recursion#02:
        function deepCloning(obj) {
            if (obj instanceof Object) {
                let cloned = {};
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        cloned[key] = deepCloning(obj[key]);
                    }
                }
                return cloned;
            }
        }
        clone = deepCloning(user);
        console.log(user.sizes === clone.sizes); // two independent object compared

        // Garbage collection: when reachablilty is not there fro any variables or memory location than it can be garbage collected
        user = { name: "Doe" };
        admin = user;
        user = null;
        console.log(admin.name);
        admin = null;
        // console.log(admin.name); // now it's garbage collected
        // Interlinked Objects:
        function marry(man, woman) {
            woman.husband = man;
            man.wife = woman;
            return {
                father: man,
                mother: woman
            }
        }
        let family = marry({ name: "John" }, { name: "Jane" });
        console.log(family);
        // lets remove two references
        delete family.father;
        delete family.mother.husband;
        console.log(family); // outgoing references don't matter only incoming ones matters and make object reachable, now "John" is unreachble but "Jane" is available
        delete family.mother;
        console.log(family);
        // unreachable island, when refenrece is removed from memory 
        family = null;
        console.log(family);
        // garbage collection algorthim is caled "mark-and-sweep", all objects that are not marked gets removed

        // Object methods and "this", ojects are created to representt real world entities
        user = {
            name: "Doe",
            age: 29
        };
        // objects can have methods
        user.sayHi = function () {
            console.log("Hello");
        };
        user.sayHi();
        function sayHi() {
            console.log("Hello");
        }
        user.sayHi = sayHi;
        user.sayHi();
        // when we write objects to represent entities that's called OOP, and how to organize interactions between them
        user = {
            sayHi: function () {
                console.log("Hello");
            },
            sayHello() {
                console.log("Hello");
            }
        };
        user.sayHi();
        user.sayHello();
        // methods use of "this", its common that an object method needs to access information stored in object to do it's job, to access object a method can use "this"
        user = {
            name: "Doe",
            age: 29,
            sayHi() {
                // console.log("Hello "+this.name+" age: "+user.age);
                console.log("Hello " + this.name + " age: " + this.age);
            }
        }
        user.sayHi(); // value of "this" is what's before dot, in this case it's user
        // but such user.name type of hard cooding within an object is unreliable, consider this:
        admin = user;
        user = null;
        // admin.sayHi(); // TypeError for user null
        admin.sayHi(); // now it works duee to use of "this" instead of "user" in sayHi(..)
        // "this" is not bound, it can be bound by any function even if it's not a method of an object
        user = { name: "Jane" };
        admin = { name: "Petra" };
        function sayHi() {
            console.log(this.name);
        }
        // using same funtion in both objects
        user.f = sayHi;
        admin.f = sayHi;
        // "this" have different context in eacc these call, calling without an object value of "this" is "undefined" in this case otherwise it's Global Object
        user.f();
        admin.f(); // accessing using dot notation
        admin['f'](); // using object bracket notation
        // consequeence of undounded "this", in JS "this" value is dependent on not where method/property is declared but in where it's been called on from, as in wht's before dot matters
        // in JS "this" is bound free, thus it has greater flexibility can create more possiblities for mistakes but can be use for different objects which is a huge benefactor of "this"
        // Arrow function doesn't have any "this", but lexicallly allow this and access value of "this" from outer function
        user = {
            firstName: "Ilya",
            sayHi() {
                let arrow = () => console.log(this.firstName); // it's useful when we dont want separetly define "this" but rather takee it from outer function around it's context
                arrow();
            }
        }
        user.sayHi();

        // Excercises:
        // Task#01: using "this" in object lieteral
        function makeUser() {
            return {
                name: "Jane",
                ref: this,
                ref2() {
                    return this;
                }
            };
        }
        user = makeUser(); // "this" undefined, because it's called as a function not as a method on an object
        console.log(user.ref.name); // an error
        console.log(user.ref2().name); // but this works because, user.ref() is a method and context of "this" is returning object and thus accessing "name"

        // Task#02: create a calculator:
        let calculator = {
            // num1: null,
            // num2: null,
            read() {
                this.num1 = +prompt("enter value: ", 1);
                this.num2 = +prompt("enter value: ", 1);
            },
            sum() {
                return this.num1+this.num2;
            },
            mult() {
                return this.num1 * this.num2;
            }
        };
        calculator.read();
        console.log(calculator.sum());
        console.log(calculator.mult());

        // Task#03: Chaining:
        let ladder = {
            step: 0,
            up() {
                this.step++;
                return this;
            },
            down() {
                this.step--;
                return this;
            },
            showStep() {
                console.log(this.step);
                // return this;
            }
        };
        ladder.up().up().down().showStep(); // return object itself from every call and that's how you can chain them up like that instead linearly putting them in sequence
        
        // Constructor, operator "new", litaral syntax allows us to create on object but when we need multiple similar objects we need to use "new"
        // Constructor Function, they are similar t normal functions but naming conventions requires it to start with Capital letters and should be executed with only "new" operator
        function User(name) {
            this.name = name;
            this.isAdmin = false;
        }
        user = new User("Lassi");
        console.log(user.name, user.isAdmin);
        // when a function is executed with "new", it does following steps:
        // - a new empty object is created and assigned to "this"
        // - function body executes, usually it modifies "this" adds new properties to it (e.g. this.name = name)
        // - value of "this" is returned
        // in other words, new User(..) does something like this:
        function User(name){
            // this = {}; // implicitly
            // adds properties to "this"
            this.name = name;
            this.isAdmin = false;
            // return "this" // implicitly
        }
        // so when user = new User("Claire") gives same result as:
        user = {
            name: "Claire",
            isAdmin: false
        };
        // if we want to create other users using new User(..) will make our code much maintainable and easy to read
        // and that's main purpose of using Constructor functions- to implement reusable object creation code
        // when you need to encapsulate your code tht construct a single complex object without future reuse then we can wrap them in a constructor function like this:
        user = new function() {
            this.name = "someBody";
            this.isAdmin = false;
        };
        // constructor Mode Test: new.target: this syntax is rarely used, and it's used  to check whether it was called with "new" operator or without it, using new.target property
        // it's empty for regular function calls and equals function if called with "new":
        function User() {
            console.log(new.target);
        }
        // without "new", regular call
        User(); // undefined
        // with new, constructor mode
        new User(); // function User() {..}
        //  we can also make both new and regular calls to do same, like this:
        function User(name) {
            if(!new.target) return new User(name) // when not used "new" operator add new name
            this.name = name;
        }
        let someBody = User("someBody"); // redirects call to new User() {..}
        // console.log(someBody.name);
        someBody = new User("someBody");
        console.log(someBody.name);
        // Return from Constructor Functions, usually constructors doesn't have a return statement, their task is to write stuff into "this" and becomes result
        // but if ther's any "return" statement then rules are simple:
        // - "return" is called with an "object" then that object is returned instead of "this"
        // - "return" is called with a primitive value then it's ognored
        // in other words "return" with an "object" returns that object, in all other cases "this" is returned
        // consider this scenario where "return" overrides "this" by returning an object:
        function BigUser() {
            this.name = "Claire";
            return {name: "Baeebeee"}; // returns this object instead
        }
        console.log(new BigUser().name); // got that object property
        // another scenario where an empty "return":
        function SmallUser() {
            this.name = "shimiee";
            // return;
            return; // returns "this"
        }
        console.log(new SmallUser().name);
        // user = new SmallUser;
        // console.log(new SmallUser.name); // we can omit parentheses if constructor doesn't have any parameters
        // console.log(user.name);
        // Methods in Constructor Function, constructor fuction can have proeprties and as well as methods and can have access to them
        function User(name) {
            this.name = name;
            this.sayHi = function() {
                console.log("Some Name : "+this.name);
            };
        }
        someBody = new User("Baeebeee");
        someBody.sayHi();
        // Excercises:
        // Task#01:two functions - one object: new A() === new B()? it's only possible when "new" returns shared object instead of "this":
        obj = {};
        function A() {
            this.check = true;
            // return obj;
            return obj;
        }
        function B() {
            // this.check = false;
            this.check = true;
            // return obj;
            return obj;
        }
        a = new A();
        b = new B();
        console.log(a === b); // true, unless returns default "this" from constructor function
        // Task#02:Create "new" Calculator: read(2 params), sum(), mult():
        function Calculator() {
            this.read = function() {
                this.a = +prompt("enter value", 1);
                this.b = +prompt("enter value", 1);
            };
            this.sum = function() {
                return this.a + this.b;
            };
            this.mult = function() {
                return this.a*this.b;
            };
        }
        calculator =  new Calculator();
        calculator.read();
        console.log("Sum = "+calculator.sum(), "Mult = "+calculator.mult());
        // Task#03:Create "new" Accumulator: store current value in property "value", read(1 param) to add it to value:
        function Accumulator(startingValue) {
            this.value = startingValue;
            this.read = function() {
                // let a = +prompt("enter value", 0);
                // this.value += a;
                this.value += +prompt("enter value", 0);
            }
        }
        let accumulator = new Accumulator(1);
        accumulator.read();
        accumulator.read();
        console.log(accumulator.value);
        
        //  Optional Chaining
        user = {};
        console.log(user.address); // undefined
        // console.log(user.address.street);  // error
        // in web development when we look for an elelment that is not available we get a null pointer exception but when tried to do some acitivity on it we get an error for Null pointer activity
        // to compensate and workaround that situation we can use ternary operator to throw an undefined rather than an error:
        console.log(user.address?user.address.street:undefined);
        // or alternatively bettwer way to write it using && operator:
        console.log(user.address && user.address.street);
        // to avoid repetition of property names, comes uses of Optional Chaining:
        // "?." stops evaluation if ppart before it is "undefined/null" andd returns that part, (e.g. value?.prop - value otherwise null/undefined)
        console.log(user?.address?.street); // object traversal is same as usual if you had anything after street.road.house, it'd try to access just same after Optional Chaining
        console.log(user.address?.street); // "user" exists but address and rest is optional, also "?." immediately stops or short circuits if left side evaluates to undefined or null or doesn't exist
        // console.log(notuser?.what) // if variable object is not declared then triggers an error
        // other variants ?.() or ?.[], "?." is not an operator rather a special syntax construct, which also works with functions and square brackets
        let userAdmin = {
            admin() {
                console.log("An Admin");
            }
        };
        userAdmin.admin?.(); // an admin, admin property exist in userAdmin
        let userGuest = {};
        console.log(userGuest.admin?.()); // undefined, evaluations stops without any error
        let user01 = {
            firstName: "Jane"
        };
        let user02 = null;
        let key = "firstName";
        console.log(user01?.[key], user02?.[key], user01?.[key]?.something?.not?.existing); // "jane", "undefined" "undefined"
        // we can also use it (?.) with "delete" operator
        delete user01?.firstName;
        console.log(user01?.firstName);
        // "?." is safe for reading and deleting but not for writing:
        user02 = {};
        // user02?.name = "Nope"; // Error, because it evaluates to undefined, and assignment into an undefined doesn't work

        // Symbol Type: by specification object property keys maybe either string type or symbol type only, lets explore how using symbol can be beneficial to us
        // "symbol" represents an unique identifier, a value of thi type can be created using Symbol():
        let id = Symbol();
        // we can also give symbol description, known as symbol name, it's most useful in debuging processes:
        id = Symbol("id");
        // symbols are guranteed to be unique, even if wee create many symbols with same descriptions, they are of different values:
        id2 = Symbol("id");
        console.log(id === id2);
        // symbols don't auto convert to a string:
        // console.log(id2); // TypeError?.
        console.log(id2, id2.toString(), id2.description);
        // Hidden Properties, symbols allows us to create "hidden" properties of an object that no other part of code can accidentally access or overwrite:
        user = {
            name: "Claire"
        };
        id = Symbol("id");
        user[id] = 1;
        console.log(user[id]); // we can access data using symbol key and there will be no conflict of names or identifiers even if they share same descriptions
        // when sing symbols vallue overwritten is not an option as it would be for usual string type variables when appeared to be samee named
        // Symbols in object literals, we need to put square bracket around it:
        id = Symbol("id");
        user = {
            name: "Baeebeee",
            [id]: 1234 // not "id":123, rather [id]:123
        };
        console.log(user[id]);
        // Symbols are skipped by for..in loop:
        id = Symbol("id");
        user = {
            name: "Baeeebeeeee",
            age: 29,
            [id]: 4321
        };
        for(let key in user) console.log(key); // no symbols showed up, also Object.keys(..) ignores them
        console.log(user[id]) // direct access is avaialble
        // Object.assign(..) copies both string and symbol characters:
        id = Symbol("id");
        user = {
            [id]: 1212,
            name: "Jane"
        };
        clone = Object.assign({}, user);
        console.log(clone.name, clone[id]);
        // Global Symbols, sometimes w want same named symbols to be same entities, meaning exactly same property
        // there exist a Global Symbol Registry, we can create symbols in it and keep it there for posterity and it also guarantees samee symbols are being used when used repeatedly with same symbol name
        // to read from registry: Symbol.for(key)
        // consider following:
        // read from global registry
        id = Symbol.for("id"); // if symbols was not there previously , now it's created
        // read it again perhaps from another code base or part of code
        id2 = Symbol.for("id");
        // check equality
        console.log(id === id2);
        //  if we want application widee symbol and accessible everywhere in code base, that's what they are for
        // Symbol.keyFor(..) is reversed of Symbol.for(key), where it returns a name by a global symbol unlike returning a symbol by name:
        // get symbol by name
        let sym = Symbol.for("name");
        let sym2 = Symbol.for("id");
        // get name by symbol
        console.log(Symbol.keyFor(sym), Symbol.keyFor(sym2)); // internally uses global registry for symbol name, it doesn't work for non global symbols, it'll return "undefined"
        //  any symbols have it's description property:
        let globalSymbol = Symbol.for("name");
        let localSymbol = Symbol("name");
        console.log(Symbol.keyFor(globalSymbol), Symbol.keyFor(localSymbol)); // name, undefined
        console.log(localSymbol.description, globalSymbol.description); // name name
        user = {
            name: "Baeeebeeeee",
            age: 29,
            [id]: 4321
        }; 
        console.log(Object.getOwnPropertySymbols(user), Reflect.ownKeys(user)) // to get all keys,  all keys including sybolic one's

        // Object to Primitives Conversions, to do conversion JavaScript tries to find and call these three object methods:
        // - call obj[Symbol.toPrimitive](hint), method with symbolic key Symbol.toPrimitive(as in System Symbol), if such method exists
        // - otherwise if hint is "string", try obj.toString() and obj.valueOf(), whatever exist
        // - otherwise if hint is "number" or "default", try obj.valueOf() and obj.toString(), whatever exists
        // Symbol.toPrimitive:
        user = {
            name: "Delilah",
            money: 1100,
            [Symbol.toPrimitive](hint) {
                console.log(`hint : ${hint}`);
                return hint === "string" ? `{name: "${this.name}"}` : this.money
            }
        };
        // conversion demo:
        console.log(user); // hint: string -> {name:"delilah"}
        console.log(+user); // hint: number: 1100
        console.log(user + 500) // hint: default: 1600
        // user becomes a self descriptive string or money ammmount depending on conversion, user[Symbol.toPrimitive] handles all converesions
        // toString/valueOf: toString -> valueOf for "string" hint and valueOf -> toString for "number" or otherwise
        // - toString returns a string "[object Object]"
        // - valueOf method returns object itself
        user = {name: "Baeebeee"};
        console.log(user); // [object Object]
        console.log(user.valueOf() === user); // true, it returns object itself
        // consider following: instead of Symbol.toPrimitive, using both toString and valueOf methods
        user = {
            name: "Claire",
            money: 1100,
            // for "string" as hint
            toString() {
                return `{name:"${this.name}"}`;
            },
            //  for "number" as hint
            valueOf() {
                return this.money;
            }
        }
        console.log(user); // toString -> {name: "Claire"}
        console.log(+user); // valueOf -> 1100
        console.log(user+500); // valueOf -> 1600
        //  often we want a single catch-alll place to handle all primitives conversion, we can implement toString only like this:
        user = {
            name: "Baeebeee",
            // mmoney: 1100,
            toString() {
                return this.name;
            }
        };
        console.log(user);
        console.log(user+500);
        // Futher Conversion, type conversion converts operands to appropriate types before operations:
        obj = {
            // toString handles alll coonversions in absence of other methods
            toString() {
                return "2"
            }
        };
        console.log(obj * 2); // 4, converted to 2 from "2" and multiplied
        console.log(obj + 2) // "22" conversion to primitive and returned concatenated strings
        // 3 types of hints: "string", "number" and "default", "default" hint handled same way as "number"
        **/
    </script>
</body>

</html>