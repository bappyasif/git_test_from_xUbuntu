<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Promises</title>
</head>

<body>
    <script>
        // Promise, expects something to be returned from a request after it's made, either indicating a success or failure as a response
        // after a request is made through Promise, a future value holds present as a placeholder for response outcome to be resolved in either success or failure
        // Values Now and Later, lets understand this with help of callbacks
        function add(getX, getY, cb) {
            let x, y;
            getX(function (val) {
                x = val;
                // both ready
                // cb(x+y);
                // cb = x + y
                if (y !== undefined) {
                    cb(x + y);
                    cb = x + y
                    // return cb(x+y); 
                }
            });
            getY(val => {
                y = val;
                // cb(x+y);
                // cb = x + y;
                // both ready
                if (x !== undefined) cb(x + y);
            });
            // return cb;
            // console.log(cb);
            // console.log(x+y);
        }
        // fetchX, fetchY are sync or async functions
        // add(fetchX, fetchY, function(sum) {
        //     console.log(sum);
        // });
        // function getchX() {
        //     let x = 4;
        //     return x;
        // }
        // function getchY() {
        //     let y = 4;
        //     return y;
        // }
        // function getchX(x) {
        //     // x = 4;
        //     return x;
        // }
        // function getchY(y) {
        //     // y = 4;
        //     return y;
        // }
        // add(getchX, getchY, function(sum) {
        //     // console.log(sum);
        //     console.log(getchX+getchY);
        // });
        // add(function getX(x) {return 4}, function getY(y) {return 4}, sum => console.log(sum = getX(4) + getY(4)))
        // function test(x, cb) {
        //     let y = x + 22;
        //     cb(y);
        // }
        // test(100, val => console.log(val));        
        // add(x => 4, y => 4, function(sum) {
        //     console.log("??",sum);
        // });
        // add(getX(4), getX(4), function(sum) {
        //     console.log(sum);
        // });
        // add(x=>getchX(4), y=>getchY(4), function(sum) {
        //     console.log(sum);
        // });
        // add(getchX(4), getchY(4), function(sum) {
        //     console.log(sum);
        //     // console.log((x,y)=>sum = x+y);
        // });
        add(x => x(4), y => y(4), function (sum) {
            console.log(sum);
        });
        // we are treating x and y are as future values, add function from outside doesn't care whether x or y are both available right away or not
        // it normalizes now and later and thus we can rely on a predictable outcome of add function operation, we make both now and later to be later and all operation becomes async

        // Promise Value, lets understand structure of Promise call first
        function addPromise(xPromise, yPromise) {
            // Promise.all([..]) takes an array of Promises
            // add function returns a new Promise that waits on them all to finish
            return Promise.all([xPromise, yPromise])
                // when that promise is resolved, let's take the received "X" and "Y" values and add them together
                .then(function (values) {
                    // values is an array of message from previously resolved Promises
                    return values[0] + values[1];  // once returns it's also a Promise, if needed it can be handled with as well
                });
        }
        // fetchX or fetchY return promises for their respective values, which may be ready now or later
        // addPromise(fetchX(), fetchY())
        // // we get a promise back for sum of those two numbers, now we chain-call then(..) to wait for resolution of that returned promise
        // .then(function(sum) {
        //     console.log(sum)
        // });
        // addPromise(x=>4, y=>4)
        // .then(function(sum) {
        //     console.log(sum)
        // });
        // addPromise(x=>x(4), y=>y(4))
        // .then(function(sum) {
        //     console.log(sum)
        // });
        addPromise(4, 4)
            .then(function (sum) {
                console.log(sum)
            });
        // fetchX() and fetchY() are called on directly, are passed into add(..), they time-time independent future values
        // second layer is returned Promise that add(..) creates via Promise.all([..]) which we wait on by calling then(..), after add(..)completes "sum" future value is ready and we can print it out
        addPromise(2, 2)
            .then(function (sum) {
                console.log(sum)
            },
                // rejection handler
                function (err) {
                    console.log(err); // ahh bummer
                }
            );
        // With Promises, then(..) can takee two functions, first for fullfilment and second one for rejection
        // once a Promise is resolved, it becomes immutable value at that point of time can then be observed as many times as necessary
        // Promise is externally immuatbble once resolved, which means it's not possible for one party to affect another party's ability to observe Promise resolution
        // Promises are an easily repeatable mechanism for encapsulating and composing "future values"

        // Completion Event or Continuation Event, as a flow-control-mechanism, a temporal this-then-that in an asynchronous task
        // With callbacks "notification" of task finished, would be a our callback invoked by our task(e.g. foo(..)), but with Promises we turn relationship around and axpect that we can listen for an event from foo(..) and when notified, proceed accorrdingly
        // function foo(x) {
        //     // start something, that could take a while
        //     return foo(x)
        // }
        // foo(42).then(
        //     // on completion
        //     function success(comp) {
        //         // console.log(comp);
        //         // do our next step
        //     },
        //     // on failure
        //     function failure(err) {
        //         // console.log(err);
        //         // oops, something went wrong in foo(..)
        //     }
        // )
        // here is more natuaral way we could express that in JS
        // function foo(x) {
        //     // start something
        //     return listener;
        // }
        // let evt = foo(42);
        // evt.on("completion", function() {
        //     // now wee can do next step
        // });
        // evt.on("failure", function() {
        //     // oops something went wrong
        // })
        // foo(..) expressively returns an event and calling code recieves and registers two event handlers against it
        // as we know callback themselves represents inversion of control, so inverting callback pattern is actually inversion of inversion or an universion of control, restoring back to calling code where we wanted it in first place
        // let evt = foo(42);
        // // let bar(..) listen to foo(..)'s completion
        // bar(evt);
        // // let baz(..) listen to foo(..)'s completion
        // baz(evt);
        // uninversion of control enabes a nicer separation of concerns, where bar and baz doesn't need to invoke foo(..)
        // similarly foo(..) doesn't need to know that bar and baz exist or not and are waiting to  be notified when finishes, essentially this evt is a nuetral third party negotiation between separate concerns

        // Promise Events, as you may have guessed evt event listening capability is an analogy for a Promise,In a Promised based approach previous snippet would havee foo(..) creating and returning a Promise instance
        //  and that Promise would then be passed to bar(..) and baz(..), then(..) registers "fullfilment" and/or "rejection" events(they are not typical events but sure behave as if they are)
        // function foo(x) {
        //     // start something that could take a while
        //     // construct and return a Promise
        //     return new Promise(function(resolve, reject) {
        //         // eventually, call "resolve(..)" or "reject(..)" which are resolution callbacks for that Promise
        //         // 
        //     });
        // }
        // let p = foo(42);
        // bar(p);
        // baz(p);
        // this pattern with new Promise(function(..){..}) is generally known "revealing constructor", function passed in is executed immediately (not async, to then(..)), its two parameters are resolution function for Promise
        // function bar(fooPromise) {
        //     // listen for "foo(..)" to complete
        //     fooPromise.then(
        //         function() {
        //             // foo(..) has now finished, so do bar(..) task
        //         },
        //         function() {
        //             // oops something went wrong
        //         }
        //     );
        // }
        // function baz(fooPromise) {
        //     fooPromise.then(
        //         // function() {
        //         //     // do task for baz()
        //         // },
        //         function() {
        //             // oops something went wrong
        //         }
        //     )
        // }
        // Promise resolution doesn't necessarily need to involve sending along a message as it did when we were examining Promises as future values
        // It can just be a flow control signal, as used in previous snippet
        // another way to approach this is:
        // function bar() {
        //     // foo(...) has definitely finished, so do bar(..) taask
        // }
        // function oopsBar() {
        //     // oops something went wrong in foo(..) so bar(..) didn't run
        // }
        // function baz() {
        //     // foo(...) has definitely finished, so do baz(..) taask
        // }
        // function oopsBaz() {
        //     // oops something went wrong in foo(..) so baz(..) didn't run
        // }
        // let p = foo(42);
        // p.then(bar, oopsBar);
        // p.then(baz, oopsBaz);
        // please make a note of that p.then(..).then(..) also know as chaining then and p.then(..); p.then(..) are two totally different behavior
        // up until now what we've done is knows as "splitting/forking", primary difference of passing p to bar(..) and baz(..), where we use promise to control when bar(..) and baz(..) will get executed
        // and from another approacch is in their error handling, in first snippet bar(..) gets to run in either resolution and same goes for baz(..) as well
        // but in second or another approach snippet, bar(..) only gets to run when foo(..) succeeds otherwise oopsBar(..), ditto goes for baz(..) and oopsBaz(..)
        // neither approach is correct per se but there will be scenarios where one is preferred  over than other, in either case Promise that comes back from foo(..) is used to control whtever happens next
        // moreover in both snippets end up calling then twice against same Promise, which is that once resolved/rejected can be obsrved as many times as necessary, whenevr Promise is resolved, next step is always be same, both now and later

        // Thenable Duck Typing, an important detail, how to know for sure, is it a vlaue that will behave like a Promise or not, given that Promises are constructed by new Promise(..) syntax, and p isinstamce of check would suffice but there a number of resasons that's not sufficient
        // it was decided that a way to recognize a Promise (or somethign that behaves like a Promise) would be to define something called "thenable" as ant=y object r function has a then(..) method on it, it's assumed that any such value is a Promised coonforming thenable, type checks is also known as "duck typing" in thenable functions
        // if (
        //     p !== null
        //     &&
        //     (typeof p === "object" || typeof p === "function")
        //     &&
        //     (typeof p.then === "function")
        // ) {
        //     // assume it's a thenable
        // } else {
        //     // not thenable
        // }
        // if there is a then function present in an object/function its automatically considerd as a Promise/thenable, this is ven true for if you didn't realize value has a then(..) on it
        let o = { then: function () { } };
        // make v linked to o via prototype 
        let v = Object.create(o);
        v.someStuff = "cool";
        v.someOtherStuff = "not so";
        console.log(v.hasOwnProperty("then")); // false
        // it doesn't need to be directly intentional as that:
        Object.prototype.then = function () { };
        Array.prototype.then = function () { };
        let v1 = { hello: "world" };
        let v2 = ["Hello", "World"];
        console.log(v1.hasOwnProperty("then"), v2.hasOwnProperty("then")); // false false
        // if what's specified is a function that doesn't call either of it's parameters as callbacks then any Promise resolved with such value will just silently hang forever, sound implausible or unlikely
        // there were several well known non-Promise libraries with a method named then(..) called on them, and som are just incomaptible with Promise based coding, for their inablity to change to get out of way

        // Promise Trust, lets review trust issues with callbacks-only coding, when you pass a callback to a utility foo(..) and it might:
        // - call callback too early
        // - call callback too late or never
        // - call callback too few or too many times
        // - Fail to pass along any necessary environment/parameters
        // - swallow any errors/exceptions that may happen
        // characteristics of Promises are intentionally designed to provide useful, repeatable answers to all those concerns admirably

        // calling callback too early, where somtimes a task finishes synchronously and sometime asynchronously, and can lead to "race conditions", Promises can not be susceptible to this concern, because even an immediately fullfiled Promise cannot be observed synchronously
        // that is to say, when called on then(..) on a Promise, even if that alreaddy resolved, callback provided to then(..) will always be called asynchronously, no need to insert setTimeout(..), Promises prevents Zalgo automatically

        // calling callback too late, similar to prvious points, a Promise's callbacks (resolve(..) or reject(..)) by it's creation capability and predictably fired at next asynchronous tick or moment
        // when a Prmoiseis resolved all then(..) registered callbacks on it will be called in order immediately at next asynchrnous oppotunity, nothing can delay or affect calling of other callbacks while inside of any callbacks
        // p.then(function() {
        //     p.then(function() {
        //         console.log("C");
        //     });
        //     console.log("A");
        // });
        // p.then(function() {
        //     console.log("B");
        // });
        // A B C
        // C can not interrupt and precede B by virtue of how Promises are defined to operate

        // Promise callback scheduling quirks, it's important to note thayt relative ordering between callbacks is not reliably predictable
        // if two promises p1 and p2 are both already resolved, it should be true that p.then(..); p2.then(..) would end up calling p1 and then p2 but there are subtle cases where it mght not be true, such as:
        let p3 = new Promise(function (resolve, reject) {
            resolve("B");
        });
        p1 = new Promise(function (resolve, reject) {
            // resolve("p3!!");
            resolve(p3);
        });
        p2 = new Promise(function (resolve, reject) {
            resolve("A");
        });
        p1.then(function (v) {
            console.log(v);
        });
        p2.then(function (v) {
            console.log(v);
        });
        // A B <--not as you might expect B A
        // it's because pa is not resolved with an immediate value but with another Promise p3 with itself will resolved with value "B", p1's callback/s are behind p2's callback/s in asynchronousl Job Queue
        // to avoid such nuanced unexpected behavior, it's a good practice not to code in such a way where Ordering of multiple callbacks matters at all, avoid it if and when possible

        // Never calling any callback, nothing can prevent a Promise from notifying you of it's resolution(if resolved), one of two callbacks will always be called
        // unless callbacks has JS errors you may see different outcome than expected but callback will in fact have been called, what if a Promise itself never gites resolved, either way Promises provides an answer for that, using a higher level abstraction called a "race"
        // a utility for timing out a Promise
        function timeoutPromise(delay) {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    reject("Timeout!!");
                }, delay)
            });
        }
        // setup a timeout for foo(..)
        Promise.race([
            foo(),
            timeoutPromise(2900)
        ]).then(
            function () {
                // foo(..) fullfiled in time
                console.log("done");
            },
            function (err) {
                // either foo(..) rejected or just timed out
                console.log(err);
            }
        );
        function foo() {
            // return 42;
            // return Error;
        }
        // by this we can ensure a signal as to outcome of foo(..) to prevent it from not being called ever and hanging our program indefinitely

        // Calling too few or too many times, by definition a callback needs to be called just "once", too few might be "never" scenerio we just exmined, too many is for some reason tries to call resolve(..) or reject(..) multiple times, Promise will accept first resolution and silently ignore any subsequent attempts
        // Promise can only be resolved once, any then(..) registered callbacks will ever be called once for each, this guarantee you dont call it multiple times more than you needed causing enexpected behavior by program

        // Failing to pass along any parameters or environment, if you don't explicitly resolve with a value either way, value is undefined as is typical in JS, whatever that value might be always passed to all registered callbacks either now or in future
        // if you call resolve(..) or reject(..) with multiple parameters, alll sub sequent parameters will be ignored beyond first one, this way it's avoided by any invalid number of usages by any API calls of resolve(..) protecting of getting called more than once, so behavior is consistent and as of for environment we can always rely on to be passed on as intended by their scopes

        // swallowing any errors/exception, if you reject a Promise with a reason (aka error message), that value is passed to rejection callback/s
        // if at any point in creation of a Promise a JS exception error occurs that exception will be caught and will force Promise in question to become rejected
        p = new Promise(function (resolve, reject) {
            foo().bar(); // foo(..) is undefined, so error
            resolve(42); // never gets to that
        });
        p.then(function fullfiled() {
            // never get to this
        },
            function rejected(err) {
                // err will be "TypeError" exception object from foo.bar() line
                console.log(err);
            }
        );
        // JS exception that occurs from foo.bar() becomes a Promise rejection that you can catch and response to in your thenable function as it's shown, and it also solves another potential Zalgo moment of synchronous reaction rather asynchronous behavior reducing race conditions chances
        // wha happens if a Promise is fullfiled but JS exception is in observation( e.g. in then(..)), such as:
        p = new Promise(function (resolve, reject) {
            resolve(42);
        });
        p.then(
            function fullfiled(msg) {
                foo.bar();
                console.log(msg); // never runs
            },
            function rejected(err) {
                console.log(err); // never runs
            }
        );
        // exception from foo.bar() did really got swallowed, but we failed to listen for it, which is wrong behavior, resulting p.then(..) to call itself another Promise and that'll be rejected with typeError exception
        // we could implement error handler right there but it would violate fundamental priniciple of Promises that are immutable once resolved, p was already resolved after resolve(42), so it can't be changed later to a rejection because there's an error in observing p's resoluttion

        // Trustable Promise, as you'd have noticed Promises don't get rid of calllbacks rather using it directly in foo(..) it gets sometting back from it and we pass callback to that something instead, why is this more trusting than just callbacks alone
        // solution to this already included with native ES6 Promise with implementation of Promise.resolve(..), these two promises will behave basically identically:
        p1 = new Promise(function (resolve, reject) {
            resolve(42);
        });
        p2 = Promise.resolve(42);
        console.log("<<", p1 === p2);
        // but if you pass a genuine promise to Promise.resolve(..) you get same promise back
        p1 = Promise.resolve(42);
        p2 = Promise.resolve(p1);
        console.log(">>", p1 === p2);
        // even more importantly, if you pass a non-Promise thenable to Promise.resolve(..), it'll attaempt unwrap this value untill a concrete final non-Promise-like value is extracted
        p = {
            then: function (cb) {
                cb(42);
            }
        };
        // this works but only by chance!!
        p.then(function fullfiled(val) {
            console.log(val);
        },
            function rejected(err) {
                console.log(err); // doesn't run
            }
        );
        // that p is a thenable but not a genuine Promise, let's loook at it differently than earlier
        p = {
            then: function (cb, errCB) {
                cb(42);
                errCB("muhahahaha gotcha");
            }
        };
        p.then(function fullfiled(val) {
            console.log(val);
        },
            function rejected(err) {
                // shouldn't run
                console.log(err); // this runs as well
            }
        );
        // that p is not quite trustablee as because it's not well behaved of a Promise even though a thenable as is
        // nonetheless, we can pass either of these variations of p to Promise.resolve(..) and we'll get normilized, safe result as we'd expect
        Promise.resolve(p).then(
            function fullfiled(val) {
                console.log(val);
            },
            function rejected(err) {
                console.log(err); // doesn't run
            }
        );
        // Promise.resolve(..) will accept any thenable and will unwrap until it's non-thenable value, you get a genuine Promise for Promise.resolve(..) that you can always trust
        // let's assume we're calling a foo(..) and we don't trust it's return value a well behaving Promise or not but we know it's a thenable, Promise.resolve(..) will give us a trustable Promise wrapper, to chain off of
        // don't just do this
        // foo(42).then(function(v){console.log("::",v)});
        // instead, do this
        // Promise.resolve(foo(42)).then(function(v){console.log("<>",v)})
        // another benefits to use Promise.resolve(..) around any function's return value(which is when thenable), it's much easier to normalize that function call into a well behavingasync task and avoiding Zalgo makes much better code
        // Promises are a patern that augments callbacks with trustable semantics, so that behavior is more reliable, by uninverting inversion of control of callbacks, we place control with a trustable system that was designed specifically to bring sanity to our async functionality

        // Chain Flow, Promises are not just a mechanism for a single-step this-then-that sort of operations, that's just building blocks, but it tturns out we can string along multiple Promises together to represent a sequence of async steps
        // key to making this work is built on these two behaviors, which are intrinsicc to Promises:
        // - everytime you call then(..) on Promise it creates and returns a new Promise which we can chain with
        // - whatever value you return from then(..) call's fullfilment callback(usually it's first parameter) is automatically set as fullfilment of chained Promise from first first then/point
        p = Promise.resolve(21);
        p2 = p.then(function (v) {
            console.log(v);
            return v * 2; // fullfils p2 with a value of 42
        });
        // chaining off of p2
        p2.then(function (v) {
            console.log(v);
        });
        // it's a little annoying to have to create an intermediate variable like p2 or as such, that's when chaining comes into play
        p = Promise.resolve(21);
        p.then(function (v) {
            console.log(v);
            return v * 2;
        }).then(function (v) {
            console.log(v);
        });
        // what if we want step 2 wait for step 1 to do someting asynchronously rather than something immediate return
        // like Promise.resolve(..), same sort of unwrapping happens if you return a theable or Promise from fullfilment or rejection function handler
        p = Promise.resolve(21);
        p.then(function (v) {
            console.log(v);
            // create a Promise and returning it
            return new Promise(function (resolve, reject) {
                // fulllfil value of 42
                resolve(v * 2);
            });
        }).then(function (v) {
            console.log(v); // prints 42
        });
        // if we introduce asynchrony to that wraping Promise, everything still works nicely and same
        p = Promise.resolve(21);
        p.then(function (v) {
            console.log(v);
            return new Promise(function (resolve, reject) {
                setTimeout(() => {
                    resolve(v * 2);
                }, 200);
            });
        }).then(function (v) {
            console.log(v); // prints 42 after 200ms from previous step
        });
        // that's incredibly powerful, now we can construct sequence of however many async steps as we want and can delay next step as necessary
        // if you dont return any value then an undefined value would passed on and Promise stiull chained together in same way, each Promise resolution is thus just a signal to proceed to next step
        // to illustrate more on chaining, let's create a utility function which will havee delay-Promise without resolution messages, so that we can reuse for multiple steps:
        function delay(time) {
            return new Promise(function (resolve, reject) {
                setTimeout(resolve, time);
            });
        }
        delay(110).then(function step2() {
            console.log("step2 after 110ms delay");
            return delay(200);
        }).then(function step3() {
            console.log("step3 after 200ms delay");
        }).then(function step4() {
            console.log("step 4 next job");
            return delay(47);
        }).then(function step5() {
            console.log("step after another 47ms");
        });
        // 200ms delay promise and chain promise that second tthen(..), it's easier to mentally combine these two promises together, because mechanism automatically does it for you
        // you could think of return delay(200) as creating a promise that replaces earlier returned chained promise (e.g. delay(100))
        // even though, sequences of delays with no message passing isn't a terribly useful example of Promise flow control
        // lets look into something more probable and practical scenario, instead of timers lets consider using ajax requests:
        // assume an ajax ({url}, {callback}) utility function
        function request(url) {
            return new Promise(function (resolve, reject) {
                // ajax callback should be our Promise's resolve(..) funtion
                //  ajax(url, resolve);
                // fetch(url, resolve);
            });
        }
        // let's define a request(..) utility that constructs a promise to represent completion of ajax(..) call:
        request("https://some.url").then(function (response1) {
            return request("https://some.url/2?v=" + response1);
        }).then(function (response2) {
            console.log(response2);
        });
        // once we have response from our initial request(..) call response that we had, we used it to construct our new returned  request(..) url for that call
        // and within our second then(..) function we used that returned response from our async flow control andd prints it in console.
        // Promise chain that w construct is not just for our multi step async sequence flow control but it's also acts as a message channel to propagate from stp to step
        // An error or exception is on a per-Promise basis, which means it's possible to catch error at any time and reset chain back to normal at that point:
        // step 1
        request("https://some.url")
            // step 2
            .then(function (response1) {
                foo.bar(); // undefined error
                // never runs
                return request("https://some.url/2?v=" + response1);
            })
            // step 3
            .then(
                function fullfiled(response2) {
                    // never runs
                },
                function rejected(err) {
                    console.log(err); // typeerror from foo.bar() error
                    return 42;
                }
            )
            // step 4
            .then(function (msg) {
                console.log(msg); // 42
            });
        // when error occurs in step 2, rejection handler catches in step 3 and returns 42(if any) and handler fullfils promise for step 4 succh that chain is now back in fullfilment state
        // when returning a Promise from either fullfilment or rejection handler, as it's in step 3 instead of returning an immediate value we could have returned a new Promise which could delay step 4
        // if there was any error in either handler of any then(..) causes next chained promise to be immediately rejected with that exception, if you only pass a fullfilment handler in your Promise and rejection handler is subsituted:
        p = new Promise(function (resolve, reject) {
            reject("oops");
        });
        p2 = p.then(function fullfiled() {
            // never runs
        }
            // assumed rejection handler, which is not available here
        );
        // as you can see assumed rejection handler simply rethrows error, which ends up in p2 rejecting with same error as well, this allows error to propagate along promise chain until an explicitly defined rejection handler is encountered if any
        // what if a proper fullfilment function is never passed into a promise parameter to then(..), there's also a default handler substituted:
        p = Promise.resolve(42);
        p.then(
            // assumed a fullfilment handler, if ommited or anyother non function value is passed then null
            null,
            function rejected(err) {
                console.log(err); // never runs
            }
        )
        // .then(function(response) {console.log(response)})
        // then(null, function(err) {..}) pattern only handling rejections(if any) but letting through fullfilment response, let's review Promises chaining flow control:
        // - a then(..) call against a Promise automatically produces a new Promise to return from call
        // - within fullfilment/rejection handlers upon returning a value or exception is thrown, new returned chainable Promise is resolved accordingly
        // - in fullfilment/ rejection handler returns a Promise and it is unwraped so that whatever it's resolution might be becomes resolution for chained Promise returneed from current then(..)
        // Promises normalize asynchrony and encapsulate time dependent value state, and that is whaat lets us chain them together in this useful way

        // Terminology: resolve, fullfil and reject
        p = new Promise(function (x, y) {
            // x or first parameter means resolve/fullfil
            // y or second parameter means reject/rejection
        });
        // event though it doesn't matter what you actually call these Promise parameters but in a way it actually does, because when other developers are interpreting it differently than what it's intended to do than it can turn out to be more disasterous than spaghetti-code alternative
        // resolution of a Promise means either fullfiling or rejecting promise to a value or state
        let fulfilledPr = Promise.resolve(42);
        let rejectedPr = Promise.reject("oops");
        // Promise.resolve(..) createes a non-Promise or non-thenable value and resolved to a value given to it, and Promise.reject(..) rejects a Promise for reason given to it
        // let's see why this word "resolve" is such unambiguos and indeed more accurate term to use over "fullfil":
        let rejectedTh = {
            then: function (resolved, rejected) {
                rejected("Oops");
            }
        };
        rejectedPr = Promise.resolve(rejectedTh);
        // as we know Promise.resolve(..) will return a recieved genuine Promise directly or unwrap a recieved thanable, so if that thenable unwrapping reveals a rejected state, so does in returned value from Promise.resolve(..)
        // as we know first callback to a Promise(..) contructor will unwrap a thenable (identically to Promise.resolve(..)) or a genuine Promise:
        rejectedPr = new Promise(function (resolve, reject) {
            // resove this promise with a rejected promise
            resolve(Promise.reject("Oops"));
        });
        rejectedPr.then(
            function fullfiled() {
                // never runs
            },
            function rejected(err) {
                console.log(err); // prints "Oops"
            }
        );
        // it's imortant to note that reject(..) does not unwrap as resolve(..) does, a subseuent rejection handler would receive actual untouched Promise/thenble passed to reject(..) not it's underlying immediate value\
        // let's see in callbacks what should they be called in literature, suggested language is fullfiled(..) and rejected(..):
        function fullfilled(msg) {
            console.log(msg);
        }
        function rejected(err) {
            console.log(err);
        }
        p.then(fullfilled, rejected);
        // here first parameter to then(..)is unambiguously always fullfilment case, so there's no need for duality of resolve terminology, and second one is for rejection behavior

        // Error Handling, most natuaral way for error handling is try..catch construct, which is only valid in synchronous only coding, thus fails in async code patterns:
        function foo() {
            setTimeout(() => {
                // baz.bar();
            }, 110);
        }
        try {
            foo();
            // later it throws global error from baz.bar();
        } catch (err) {
            // never runs
            console.log("??", err);
        }
        // in callbacks, some  standards have emerged for patterned error handling, most notably error-first-callback style:
        function foo(cb) {
            setTimeout(() => {
                try {
                    let x = baz.bar();
                    cb(null, x); // success?!
                } catch (err) {
                    cb(err);
                }
            }, 110)
        }
        foo(function (err, val) {
            if (err) {
                console.log(err); // bummer!?
            } else {
                console.log(val);
            }
        });
        // here try catch works because baz.bar() call will resolve(either success or failure) immediately, synchronously, if it was itself an async function then error inside of it wouldn't be catchable
        // callback we passed to foo(..) expeects err as it's first parameter and if exist error is assumed, else success and value would be printed, this sort fo error handling is known as async capable but it doesn't compose well
        // mutiple level of error-callbacks sequenced together with these if..else conditionals, inevitably will lead to perils of callback-hell
        // when we look into error handling for Promises with rejection handler parameter passed into then(..), Promises use split callbacks style, one for each success and rejection:
        p = Promise.reject("Ooopss!!");
        p.then(
            function fullfiled() {
                // never runs
            },
            function rejected(err) {
                console.log("??", err); // prints Ooopss!!
            }
        );
        // even though this pattern makes total sense but for some nuances it's but difficult to grasp:
        p = Promise.resolve(42);
        p.then(
            function fullfiled(msg) {
                // numbers dont have string functions, so it'll throw an error
                console.log(msg.toLowerCase());
            },
            function rejected(err) {
                // never runs
                console.log(err);
            }
        );
        // as msg.toLowerCase() throws an error our error handler function doesn't get to run, as we know once a Promise gets resolve it's immutable
        // and only promise that can notify about this error is one that returned form p.then(..), which in this case we dont capture
        // in Promise API when used in an invalid way and an error occurs that prevents proper Promise construction, resulting immediately thrown exception, not a rejected Promise
        // you can't get a reject Promise, if you don't use Promise API validly enough to actualy construct a Promise in fist place, some faile Promise construction examples: new Promise(null), Promise.all(), Promise.race(42), aand so on

        // Pit of dispair, in Promise error handling is one of those pattern, by default you expect any error to be swallowed by Promise state, when failed to observe this state usually goes to despair
        // to avoid loosing an unattended error in silence, as it's a bad practice, so, for Promise chains is to always end with a final catch(..) like:
        p = Promise.resolve(42);
        p.then(
            function fullfiled(msg) {
                // number dont have string methods, so it'll throw an error
                console.log(msg.toLowerCase());
            }
        )
        // .catch(handleErrors);
        // but this doesn't solve this problem, what if handleErrors has errorneous itself, we'll end up loosing litening to it then, because it too could fail due to that

        // Uncaught Handling, it's not an exactly easy problem to sove, there are other ways to approach this, where many would say are better, some Promise libraries have added methods for registering something liek a Global Unhandled rejection handler, which would be called instead of globally thrown error
        // this pattern is also troublesome because, significant delay prior to rejejction can be false positives, and sometime you might want a request to follow through till you have got something, before throwing an error
        // another suggested approach is to use done(..), it doesn't create and return a Promise, so it doesn't report problems to a chaained Promise that doesn't exist
        // what happens instead is, inside done(..) rejection handler would be thrown as a global uncaught error, in developer console basically:
        p = Promise.resolve(42);
        p.then(
            function fullfiled(msg) {
                // numbers dont have string methods, so it'll throw error
                console.log(msg.toLowerCase());
            }
        )
        // .done(null, handleErrors); // if handleError(..) caused it own exception it'd be thrown globally here as well
        // even though it looks a lot cleaner but it's not part of ES6 standard, interestingly Browsers can track and report Promise objects while its garbase collected for unhandleed errors, and thus it knows to report to developer console, there are other alternative as well and we'll see

        // Pit of Success, it's just theoretical how a Promise could changed to behave, lets take a look:
        // - Promises could default to reporting any rejection(on to developer console) if no error handler been registered for that Promise
        // - where you want a rejected Promise to hold on to it's rejected state indefinitely bfore observing, you could call defer(..) which seppresses automatic error handling on that Promise
        // when rejected, by default it's reporting fact to developer console or explicitly define a method defer(..) to handle errors, in either case you control false positives
        // p = Promise.reject("Ooppss").defer();
        // foo(..) is Promise aware
        // foo(42).then(
        //     function fullfiled() {
        //         return p;
        //     },
        //     function rejection(err) {
        //         // handle foo(..) error 
        //         console.log(err);
        //     }
        // );
        // while we create p, we're going to wait until we observe its rejection so we call defer(..) thus avoiding global reporting, defer(..) simply returns ame Promisefor chaining purposes
        // Promise returned from foo(..) gets an error handler attached right away so no global reporting (it's implicitly opted out) but Promise returned from then(..) has no defer(..) so if it rejects it'll be reported to developer console as an uncaught error

        // Promise Patterns, there are a lot of variations on asynchronous patterns that we can build as abstractions on top of Promises, these patterns serve to simplify expression of async flow control, which makes our code more reasonable and maintainable even in most complex parts of our program
        // two such patterns are codified in ES6 Promise API implementation, so we can get most of them for free and to use it as a building blocks for other patterns
        // Promise.all([..]), in an async sequence(Promise chain), only one async task is being coordinated at any ggiven mmoment, step 2 follows steps 1 and 3 follow 2 and so on and so forth, but what about two or more steps concurrently or in parallel
        // in classic programmin teerminology, a gate is a mechanism taht waits on two or more parallel/concurrent tasks to complete before continuing, doesn't matter what order they finish but they havee to be complete in order to gate to be open and let fflow control through, we call this pattern all([..])
        p1 = request("https://some.url/1");
        p2 = request("https://some.url/2");
        Promise.all([p1, p2]).then(function (msgs) {
            // both p1 and p2 fullfils and pass in their messages here
            return request("https://some.url/3?v=" + msgs.join(","))
        }).then(
            function (msg) {
                console.log(msg);
            }
        );
        // Promise.all([..]) expects an array all those fullfilment messages will be found, from those passed in Promises and in samee order, Promise.all([..]) can include Promises, thenables or even immediate values
        // each value is passed through Promise.resolve(..) to ensure a genuine Promise to be waited on, so an immediate value will be normalized into a Promise for that value
        // main Promise returned from promise.all([...]) wil only be fullfiled when all its constituent Promises are fullfiled , if any of those promises are rejected main Promise is immediately rejected, discarding all results from any other Promises
        // always attach an error/rejection handler to every Promise even and specially which come back fro Promise.all([..])

        // Promise.race([..]), it only concerns with one of those (usually only first promise) promises when fullfiled letting other Promises fall away, classically known as latch but in Promises it's called a  "race" but dont confuse with "race condition" in classical term which is a bug and should be avoided at all times
        // Prromise.race([..]) also expects an array arguments, containing one or more Promises, thenables or immediate values, note to self first one listed in promise list will bviously win race
        // similar to .all([..]) .race([..]) will fullfil if any Promise resolution is fullfiledand reject when any resolution rejects, a race requires at least one runner so when passed in an empty array instead of immediately resolving  main race never resolves, this is a footgun ES6 should throw some sort of synchronous error instead.
        // so, never ppassed in an empty array to a Promise.race([..])
        p1 = request("https://some.url/1");
        p2 = request("https://some.url/2");
        Promise.race([p1, p2]).then(function (msg) {
            // either p1 or p2 fullfils and wins race
            return request("https://some.url/3?v=" + msg)
        }).then(
            function (msg) {
                console.log(msg);
            }
        );
        // because only one promise wins, fullfilment value is a single message not an array as it was for Promise.all([..])

        // Timeout Race:
        // setup a timeout for foo(..)
        Promise.race([
            foo(),
            timeoutPromise(2900)
        ]).then(
            function () {
                // foo(..) fullfiled in time
            },
            function (err) {
                // either foo(..) rejected or timedout
            }
        );
        // this pattern works in most cases but threre some nuanced scenarios to consider, and they appply both to .all([..]) and .race([..]) equally

        // Finally, developers proposed that Promises need a finally(..) callback registration, which is always called when a Promise resolves and allows you to specify any cleanup that may be ncessary
        // it might look like this:
        // p = Promise.resolve(42);
        // p.then(somthing).finallly(cleanup).then(another).finallly(cleanup)
        // in various Promise libraries, finally(..) still creates and returns a new Promise, to keep chain going, if cleanup(..) were to return a Promise, it'd linked into chain so that you could still have unhandled rejectio isssues discussed earlier
        // meanwhile we can use static helper utility that lets us observe resolution of a Promise:
        if (!Promise.observe) {
            Promise.observe = function (pr, cb) {
                // side observe pr resolution
                pr.then(
                    function fullfiled(msg) {
                        // schedule callback async Job
                        Promise.resolve(msg).then(cb);
                    },
                    function rejection(err) {
                        // schedule callback async Job
                        Promise.resolve(err).then(cb);
                    }
                );
                // return Oringinal Promise
                return pr;
            };
        }
        // here's how we'd use it in timeout example from earlier:
        Promise.race([
            Promise.observe(
                foo(),
                function cleanup(msg) {
                    // clean up after foo(..), even if it didn't finish before timeout
                }
            ),
            timeoutPromise(2900)
        ]);
        // Promise.observe(..) is just an illlustration of how you could observe completions of Promises without interfering with them, other libraries have their own solutions, regardless make sure you aren't just silently ignoring your Promises by accident

        // variation on all([..]) and race([..]), it's built in ES6 Promises, there are other several patterns with variations on those semantics:
        // - none([..]) is like transposed of all([..]), which means all Promises needs to be rejected- rejections become fullfilment values and vice versa
        // - any([..]) is like all([..]) but it ignores any rejection, so only needs one to bee fullfiled than all of them
        // - first([..]) is like a race with any([..]), which is that it ignores any rejection and fullfils as soon as there's a first Promise fullfils
        // - last([..]) is like first([..]) but only latest fullfils wins race
        // some Promise libraries provide those abstractions but you can define for yourself using mechanics of Promises, race([..]) and all([..])
        // polyfill safe guard check
        if (!Promise.first) {
            Promise.first = function (prs) {
                return new Promise(function (resolve, reject) {
                    // loops through all promises
                    prs.forEach(function (pr) {
                        // normalize value
                        Promise.resolve(pr)
                            // whichevver gets resolves first wins race, and gets to fullfil for main promise
                            .then(resolve);
                    });
                });
            };
            // if(prs === null) {Promise.first.then(function(msg) {console.log(msg)})}
        }
        // if all rejects this implementation doesn't handle that scenerio

        // concurrent iterations, sometimes you might want to iterate over a list of Promises and perform some task against all of them, like you do with synchronous array methods such as map(..), forEach(..), some(..) and every(..)
        // lets consider an asynchronous map(..) utility that takes an array of vakues could be Promises or other anything else, with a function or task t perform on against each promise and whose fullfilments is an array that holds value from each task:
        if (!Promise.map) {
            Promise.map = function (vals, cb) {
                // new promise that waits for all mapped promises
                return Promise.all(
                    // map(..) method turns into an array of Promises
                    vals.map(function (val) {
                        // replace val with a new Promise that resolves after val is async mapped
                        return new Promise(function (resolve) {
                            cb(val, resolve);
                        });
                    })
                );
            };
        }
        // in that implementation of map(..) async rejection wasn't signaled but if any synchronous rejection occurs inside of mapping callback cb(..) main Promise.map(..) returned Promise would reject too
        // let's illustrates using map(..) with a list of Promises rather than just simple values:
        p1 = Promise.resolve(21);
        p2 = Promise.resolve(42);
        p3 = Promise.reject("Ooppss!!");
        // double values in ist if they're in promises
        Promise.map([p1, p2, p3], function (pr, done) {
            // make sure item itself is a Prromise
            Promise.resolve(pr)
                .then(
                    // extract value as v
                    function (v) {
                        // map fullfilment v to new value of double
                        done(v * 2);
                    },
                    // or, map to Promise rejection message
                    done
                );
        })
            .then(function (vals) {
                console.log(vals); // [42,84,"Ooppss!!"];
            });

        // ES6 Promise API Recap
        // new Promise(..) constructor, it must be provided a function callback that is synchronously/immediatelly called, this passes in function has two function callbacks in it, one for "fullfilment" and another for "rejection" for Promise
        p = new Promise(function (resolve, reject) {
            // resolve(..) to resolve/fullfil Promise
            // reject(..) to reject promise
        });
        // reject(..) simply rejects but resolve(..) can either fullfil promise or reject it, depending on what is passed
        // if an immediate value is passed then promise is fullfiled with that value, if a genuine Promise is passed or thenable value that value is then unwrapped until it's reached it's final state/resolution adopted by promise

        // Promise.resolve(..) and Promise.reject(..) are shortcut for creating a resolved and rejected value respectively
        p1 = new Promise(function (resolve, reject) {
            reject("Oops");
        });
        p2 = Promise.reject("Opps");
        // these two promises are same or equivalent, however Promise.resolve(..) alo unwraps thenable values, so returned Promise adopts final resolution of thenable you passed in, which could either be fullfilment or rejection:
        let fullfiledTh = {
            then: function (cb) { cb(44) }
        };
        rejectedTh = {
            then: function (cb, errCb) { errCb("Oops") }
        }
        p1 = Promise.resolve(fullfiledTh);
        p2 = Promise.resolve(rejectedTh);
        // Promise.resolve(..) simply returns value directly

        // then(..) and catch(..), each Promise instance(not Promise API namespace) has then(..) and catch(..) methods, which allow registering of fullfilment and rejection handlers for Promise, once Promise is resolved one or that other handlers will be called but not both and it'll always be called asynchronously
        // then(..) takes two parameters, first one for fullfilment and other one for rejection callbacks, if either is omitted or passed as a non function value, a default callback is substituted respectively, catch(..) takes only rejection callback as a parameter and substitutes by default parameeter when a non function value is passed, its equivalent to then(null, ..)
        p.then(fullfilled);
        p.then(fullfilled, rejected);
        p.catch(rejected); // equivalent
        p.then(null, rejected); // equivalent
        // then(..) and catch(..)also create and return a new Promise which can be used to Promise flow control, if callbacks have an exception then returned Promise is rejected, if wiether calllbacks returns an immediate value that value is set as resolution value for that Promise
        // if fullfilment handler specifically returns a promise or thenable value, that value is unwrapped and becomes resolution of returned promise

        // Promise.all([..]) and Promise.race([..]) on ES6 Promise API both create nd return a Promise as their value, resolution of that promise is controlled entirely by array of promises that are passed into it
        // Promise.all([..]), all promises must be true for returned Promise to fullfil, if any rejected then main Promise gets rejected too 
        // for fullfilment you receive an array of fullfiled values and for rejection you just recieve first rejected reason value
        // Promise.race([..]), only first Promise that resolves(either fullfilment or rejection) wins race, and whatever that resolution is becomes returned Promise resolution as well, classically known as latch, first one to open latch gets through
        p1 = Promise.resolve(44);
        p2 = Promise.resolve("Hello World");
        p3 = Promise.reject("Oops");
        Promise.race([p1, p2, p3]).then(function (msg) {
            console.log(msg);
        });
        Promise.all([p1, p2, p3])
            .catch(function (err) {
                console.log(err);
            })
        Promise.all([p1, p2])
            .then(
                function (msgs) {
                    console.log(msgs).join(",");
                }
            );
        // do remember if an empty array is passed into Promise.all([..]) it will fullfil immediately whereas Promise.race([..]) will hang forever and never resolve, please bear in mind

        // Promise Limitations
        // Sequence Error Handling, limitation is in their chaining, and specefically how an error can be silently ignored accidentally, promise chain is just constituents promises wired together, ther's no entity to refer to entire chain as a single thing which means no external way to observe any errors that may occur
        // if you construct a Promise chain tat has no error handling in it, any error anywhere in chain will propagate indefinitely dow the chain until it's observed, as in by regiestering a error handler at any step otherwise it'll be logged into devloper console
        p = foo(44)
            .then(step2)
            .then(step3);
        // although it might seem sneakingly cconfusing but here p is pointing to then(Step3) call, as there is no error handling metthod obsrved in chain, we can use catch(..) method on p to get notified about errors if any occur anywhere in chain:
        p.catch(handleErrors);
        // this complete lack of ability to be notified of already handled rejection errors is a limitation that restricts capabilities in some use cases

        // Single Value, Promises by definition have a single fullfilment or rejecton reason
        // Splitting Values, consider this following snippet where foo(..) produces two values x, y, asynchronously:
        function getY(x) {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    resolve((3 * x) - 1);
                }, 110);
            });
        }
        function foo(bar, baz) {
            let x = bar * baz;
            return getY(x)
                .then(function (y) {
                    // wrap both values into an array container
                    return [x, y];
                });
        }
        foo(11, 20)
            .then(function (args) {
                let x = args[0];
                let y = args[1];
                console.log(x, y);
            });
        //  let's rearrange what foo(..) returns so that we don't have to wrap x and y into a single array value to transport through a Promise, instead we can wrap each value into it's own Promise:
        function foo(bar, baz) {
            let x = bar * baz;
            // return both these promises
            return [
                Promise.resolve(x),
                getY(x)
            ];
        }
        Promise.all(
            foo(11, 20)
        )
            .then(
                function (msgs) {
                    let x = msgs[0];
                    let y = msgs[1];
                    console.log(x, y);
                }
            );
        // is an array of promises are really better than array of values passed into a single Promise, syntactically not much of an improvement
        // but, this design approach embraces Promise design theory, it's cleanera nd flexible to let calling code decide how to orchestrate these two promises using Promise.all([..]) but certainly not an only option

        // Unwrap or Spread Arguments, array destructuring:
        Promise.all(
            foo(11, 20)
        ).then(function (msgs) {
            let [x, y] = msgs;
            console.log(x, y);
        });
        // or with parameter destructuring:
        Promise.all(
            foo(11, 20)
        ).then(function ([x, y]) {
            console.log(x, y);
        });

        // Single Resolution, most intrinsic behavior of Promises is that it can only be resolved once, fomany async use cases, you're only retriving a value once
        // imagine a scenario whwre you want to set off a sequence fo async steps in response to a stimulus such as events that cn happen multiple times like a button click, following won't work way you want it to be:
        p = new Promise(function (resolve, reject) {
            click("#smBtn", resolve);
        });
        p.then(function (evt) {
            let btnID = evt.currentTarget.id;
            return request("https://some.url/id=?" + btnID);
        }).then(function (text) {
            console.log(text);
        });
        // that behavior only works for if your application calls for button to be clicked once, when clicked more than once, p is already been resolved so rest of those calls will be ignored
        // instead you might want something like this here you might want to create a whole new Promise for each event firing:
        click("#smBtn", function (evt) {
            let btnID = evt.currentTarget.id;
            request("https://some.url/id=?" + btnID)
                .then(function (text) {
                    console.log(text);
                });
        });
        // that approach would work because it's creating a whole new Promise for each click event firing on Button
        // though it works just fine but this design violates in some respect Separation od Concerns/Capabilities, you might want to define your event handler in a differnt place in yourcode from whre you define response to event firing instead

        // Innertia, a code base remain in motion with callbacks unless acted upon by someone who is Promise-aware developer, Promises offer different paradigm, approach to refactor your code can be from somewhat little to radically different and you have to be intentional about it
        //consider callback-based scenario like following:
        function foo(x, y, cb) {
            // ajax(
            //     "https://some.url/?x="+x+"&y="+y,
            //     cb
            // );
        }
        foo(11, 31, function (err, text) {
            if (err) {
                console.log(err);
            } else {
                console.log(text);
            }
        });
        // consider this helper utility:
        if (!Promise.wrap) {
            Promise.wrap = function (fn) {
                return function () {
                    let args = [].slice.call(arguments);
                    return new Promise(function (resolve, reject) {
                        fn.apply(
                            null,
                            args.concat(function (err, v) {
                                if (err) {
                                    reject(err);
                                } else {
                                    resolve(v);
                                }
                            })
                        );
                    });
                };
            };
        }
        // this kind of utility functions are called Promisories, so that it can aid in our Promise aware coding
        // lets refactor our earlier callback based foo(..) and ajax(..) methods:
        request = Promise.wrap(ajax);
        // refactoring foo(..) but keeping it externally callback- based compatibility with othr parts of code for now
        // only use reuest(..) for Promises only internally
        function foo(x,y,cb) {
            request("https://some.url?x="+x+"&y="+y)
            .then(
                function fullfiled(text) {
                    console.log(text);
                },
                cb
            );
        }
        // better foo(..) using promisory:
        let betterFoo = Promise.wrap(foo);
        // using promisory
        betterFoo(11,31)
        .then(
            function fullfiled(text) {
                console.log(text);
            },
            function rejected(err) {
                console.log(err);
            }
        );
        // ES6 nativelly dont ship with utility functions for such promisoriesbut most libraries provide them or you can create your own, either way it's addressable without too much pain compared to callback hell

        // Promise Uncancelable, once created a Promise and registers a fullfilment and/or rejection handler for it, there's nothing that you can do to stop that propagation if somting else happens to ake that task moot
        
        // Promise  Performance, promises has more guards to protect means they tidy slower than untrustable callbacks, if implementing all gurads in adhoc callbacks is it still better than promise then can say Promise is slower otherwise not
        // another subtle issue with Promise is that, it makes everything  async even for immediately available values which makes it bit slower than ad hoc callbacks but making it predictable and avoiding race conditions which is weigh more than ad hoc call backs, Promises provides Trustablility, non-Zalgo predictablility and composability built in which benefits you immensely

        // Promises are aweesome use them as often as possible, they solve inversion of control issues, they dont get rid of callbacks instead redirect them through trustable intermidiary mechanism, a better way to address async flow in sequential fashion which helps our brain to plan and maintain JS code better
    </script>
</body>

</html>